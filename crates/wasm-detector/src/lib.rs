//! A library to detect local `.wasm` files in a repository.
//!
//! This crate provides functionality to find WebAssembly files while:
//! - Respecting `.gitignore` rules
//! - Including well-known `.wasm` locations that are typically ignored
//!   (e.g., `target/wasm32-*`, `pkg/`, `dist/`)
//!
//! # Example
//!
//! ```no_run
//! use wasm_detector::WasmDetector;
//! use std::path::Path;
//!
//! let detector = WasmDetector::new(Path::new("."));
//! for result in detector {
//!     match result {
//!         Ok(entry) => println!("Found: {}", entry.path().display()),
//!         Err(e) => eprintln!("Error: {}", e),
//!     }
//! }
//! ```

use ignore::WalkBuilder;
use std::collections::HashSet;
use std::path::{Path, PathBuf};
use wasm_metadata::Payload;

/// Well-known directories that typically contain `.wasm` files but are often ignored.
///
/// These directories are scanned separately without respecting `.gitignore` rules
/// to ensure important wasm output locations are always included.
pub const WELL_KNOWN_WASM_DIRS: &[&str] = &[
    // Rust wasm targets (the target directory is scanned for wasm32-* subdirs)
    "target", // wasm-pack output
    "pkg",    // JavaScript/jco output
    "dist",
];

/// Patterns to match within the target directory for wasm-specific subdirectories.
const TARGET_WASM_PREFIXES: &[&str] = &["wasm32-"];

/// A discovered WebAssembly file entry.
#[derive(Debug, Clone)]
pub struct WasmEntry {
    path: PathBuf,
    interfaces: Vec<InterfaceInfo>,
}

/// Information about a WIT interface or dependency found in a WASM component.
#[derive(Debug, Clone)]
pub struct InterfaceInfo {
    /// Name of the interface/package
    pub name: String,
    /// Version of the interface/package, if available
    pub version: Option<String>,
    /// Type of interface entry (dependency, child component, etc.)
    pub kind: InterfaceKind,
}

/// The kind of interface entry.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InterfaceKind {
    /// A dependency package
    Dependency,
    /// A child component
    ChildComponent,
    /// A child module
    ChildModule,
}

impl WasmEntry {
    /// Create a new WasmEntry from a path.
    fn new(path: PathBuf) -> Self {
        let interfaces = Self::extract_interfaces(&path);
        Self { path, interfaces }
    }

    /// Extract interface information from a WASM file.
    fn extract_interfaces(path: &Path) -> Vec<InterfaceInfo> {
        let mut interfaces = Vec::new();

        // Try to read and parse the WASM file
        let Ok(bytes) = std::fs::read(path) else {
            return interfaces;
        };

        let Ok(payload) = Payload::from_binary(&bytes) else {
            return interfaces;
        };

        // Extract interfaces recursively
        Self::extract_interfaces_from_payload(&payload, &mut interfaces);

        interfaces
    }

    /// Recursively extract interfaces from a payload.
    fn extract_interfaces_from_payload(payload: &Payload, interfaces: &mut Vec<InterfaceInfo>) {
        let metadata = payload.metadata();

        // Extract dependencies
        if let Some(deps) = &metadata.dependencies {
            for package in &deps.version_info().packages {
                interfaces.push(InterfaceInfo {
                    name: package.name.clone(),
                    version: Some(package.version.to_string()),
                    kind: InterfaceKind::Dependency,
                });
            }
        }

        // Extract child components/modules
        if let Payload::Component { children, .. } = payload {
            for child in children {
                let child_metadata = child.metadata();
                if let Some(name) = &child_metadata.name {
                    let kind = match child {
                        Payload::Component { .. } => InterfaceKind::ChildComponent,
                        Payload::Module(_) => InterfaceKind::ChildModule,
                    };
                    interfaces.push(InterfaceInfo {
                        name: name.clone(),
                        version: child_metadata.version.as_ref().map(|v| v.to_string()),
                        kind,
                    });
                }
                // Recursively extract from children
                Self::extract_interfaces_from_payload(child, interfaces);
            }
        }
    }

    /// Returns the path to the `.wasm` file.
    #[must_use]
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Returns the file name of the `.wasm` file.
    #[must_use]
    pub fn file_name(&self) -> Option<&str> {
        self.path.file_name().and_then(|s| s.to_str())
    }

    /// Returns the interfaces found in this WASM file.
    #[must_use]
    pub fn interfaces(&self) -> &[InterfaceInfo] {
        &self.interfaces
    }

    /// Consumes the entry and returns the underlying path.
    #[must_use]
    pub fn into_path(self) -> PathBuf {
        self.path
    }
}

/// A detector that finds `.wasm` files in a directory tree.
///
/// The detector:
/// - Respects `.gitignore` rules by default
/// - Automatically includes well-known `.wasm` locations that are typically ignored
/// - Returns an iterator over discovered `.wasm` files
///
/// # Example
///
/// ```no_run
/// use wasm_detector::WasmDetector;
/// use std::path::Path;
///
/// let detector = WasmDetector::new(Path::new("."));
/// let wasm_files: Vec<_> = detector.into_iter().filter_map(Result::ok).collect();
/// println!("Found {} wasm files", wasm_files.len());
/// ```
#[derive(Debug, Clone)]
pub struct WasmDetector {
    root: PathBuf,
    include_hidden: bool,
    follow_symlinks: bool,
}

impl WasmDetector {
    /// Create a new detector that will search from the given root directory.
    #[must_use]
    pub fn new(root: &Path) -> Self {
        Self {
            root: root.to_path_buf(),
            include_hidden: false,
            follow_symlinks: false,
        }
    }

    /// Set whether to include hidden files and directories.
    ///
    /// By default, hidden files are excluded.
    #[must_use]
    pub fn include_hidden(mut self, include: bool) -> Self {
        self.include_hidden = include;
        self
    }

    /// Set whether to follow symbolic links.
    ///
    /// By default, symbolic links are not followed.
    #[must_use]
    pub fn follow_symlinks(mut self, follow: bool) -> Self {
        self.follow_symlinks = follow;
        self
    }

    /// Detect `.wasm` files and return all results as a vector.
    ///
    /// This is a convenience method that collects all results.
    /// For large directories, consider using the iterator interface instead.
    ///
    /// # Errors
    ///
    /// Returns an error if the detection fails to complete.
    pub fn detect(&self) -> Result<Vec<WasmEntry>, ignore::Error> {
        self.into_iter().collect()
    }

    /// Find all well-known wasm directories that exist in the root.
    fn find_well_known_dirs(&self) -> Vec<PathBuf> {
        let mut dirs = Vec::new();

        // Check for pkg/ and dist/ directories
        for dir_name in &["pkg", "dist"] {
            let dir_path = self.root.join(dir_name);
            if dir_path.is_dir() {
                dirs.push(dir_path);
            }
        }

        // Check for target/wasm32-* directories
        let target_dir = self.root.join("target");
        if target_dir.is_dir()
            && let Ok(entries) = std::fs::read_dir(&target_dir)
        {
            for entry in entries.filter_map(Result::ok) {
                let path = entry.path();
                if path.is_dir()
                    && let Some(name) = path.file_name().and_then(|n| n.to_str())
                {
                    for prefix in TARGET_WASM_PREFIXES {
                        if name.starts_with(prefix) {
                            dirs.push(path);
                            break;
                        }
                    }
                }
            }
        }

        dirs
    }
}

impl IntoIterator for WasmDetector {
    type Item = Result<WasmEntry, ignore::Error>;
    type IntoIter = WasmDetectorIter;

    fn into_iter(self) -> Self::IntoIter {
        WasmDetectorIter::new(self)
    }
}

impl IntoIterator for &WasmDetector {
    type Item = Result<WasmEntry, ignore::Error>;
    type IntoIter = WasmDetectorIter;

    fn into_iter(self) -> Self::IntoIter {
        WasmDetectorIter::new(self.clone())
    }
}

/// Iterator over discovered `.wasm` files.
///
/// This iterator combines results from multiple walks:
/// 1. A main walk that respects `.gitignore`
/// 2. Additional walks for well-known directories (ignoring `.gitignore`)
pub struct WasmDetectorIter {
    /// The main walker that respects gitignore
    main_walker: ignore::Walk,
    /// Walkers for well-known directories (ignoring gitignore)
    well_known_walkers: Vec<ignore::Walk>,
    /// Current index in well_known_walkers
    current_well_known_idx: usize,
    /// Set of paths already seen (to avoid duplicates)
    seen_paths: HashSet<PathBuf>,
    /// Whether we've finished the main walk
    main_walk_done: bool,
}

impl std::fmt::Debug for WasmDetectorIter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("WasmDetectorIter")
            .field("main_walk_done", &self.main_walk_done)
            .field("current_well_known_idx", &self.current_well_known_idx)
            .field("seen_paths_count", &self.seen_paths.len())
            .finish_non_exhaustive()
    }
}

impl WasmDetectorIter {
    fn new(detector: WasmDetector) -> Self {
        // Build the main walker that respects gitignore
        let main_walker = WalkBuilder::new(&detector.root)
            .hidden(!detector.include_hidden)
            .follow_links(detector.follow_symlinks)
            .git_ignore(true)
            .git_global(true)
            .git_exclude(true)
            .build();

        // Build walkers for well-known directories (ignoring gitignore)
        let well_known_dirs = detector.find_well_known_dirs();
        let well_known_walkers: Vec<_> = well_known_dirs
            .into_iter()
            .map(|dir| {
                WalkBuilder::new(dir)
                    .hidden(!detector.include_hidden)
                    .follow_links(detector.follow_symlinks)
                    .git_ignore(false) // Don't respect gitignore for well-known dirs
                    .git_global(false)
                    .git_exclude(false)
                    .build()
            })
            .collect();

        Self {
            main_walker,
            well_known_walkers,
            current_well_known_idx: 0,
            seen_paths: HashSet::new(),
            main_walk_done: false,
        }
    }

    /// Try to get the next .wasm file from the main walker
    fn next_from_main(&mut self) -> Option<Result<WasmEntry, ignore::Error>> {
        loop {
            match self.main_walker.next() {
                Some(Ok(entry)) => {
                    let path = entry.path();
                    if path.is_file() && path.extension().is_some_and(|ext| ext == "wasm") {
                        let path_buf = path.to_path_buf();
                        self.seen_paths.insert(path_buf.clone());
                        return Some(Ok(WasmEntry::new(path_buf)));
                    }
                    // Continue to next entry
                }
                Some(Err(e)) => return Some(Err(e)),
                None => {
                    self.main_walk_done = true;
                    return None;
                }
            }
        }
    }

    /// Try to get the next .wasm file from well-known walkers
    fn next_from_well_known(&mut self) -> Option<Result<WasmEntry, ignore::Error>> {
        while self.current_well_known_idx < self.well_known_walkers.len() {
            if let Some(walker) = self.well_known_walkers.get_mut(self.current_well_known_idx) {
                loop {
                    match walker.next() {
                        Some(Ok(entry)) => {
                            let path = entry.path();
                            if path.is_file() && path.extension().is_some_and(|ext| ext == "wasm") {
                                let path_buf = path.to_path_buf();
                                // Skip if we've already seen this path
                                if self.seen_paths.contains(&path_buf) {
                                    continue;
                                }
                                self.seen_paths.insert(path_buf.clone());
                                return Some(Ok(WasmEntry::new(path_buf)));
                            }
                            // Continue to next entry
                        }
                        Some(Err(e)) => return Some(Err(e)),
                        None => {
                            // Move to next well-known walker
                            self.current_well_known_idx += 1;
                            break;
                        }
                    }
                }
            } else {
                self.current_well_known_idx += 1;
            }
        }
        None
    }
}

impl Iterator for WasmDetectorIter {
    type Item = Result<WasmEntry, ignore::Error>;

    fn next(&mut self) -> Option<Self::Item> {
        // First, exhaust the main walker
        if !self.main_walk_done
            && let Some(result) = self.next_from_main()
        {
            return Some(result);
        }

        // Then, go through well-known directories
        self.next_from_well_known()
    }
}
