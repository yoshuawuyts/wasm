use wit_parser::decoding::{DecodedWasm, decode};

/// Metadata extracted from a WIT component.
pub(crate) struct WitMetadata {
    pub package_name: Option<String>,
    pub world_name: String,
    pub import_count: i32,
    pub export_count: i32,
    pub wit_text: String,
}

/// Attempt to extract WIT metadata from wasm component bytes.
/// Returns `None` if the bytes are not a valid wasm component.
pub(crate) fn extract_wit_metadata(wasm_bytes: &[u8]) -> Option<WitMetadata> {
    // Try to decode the wasm bytes as a component
    let decoded = decode(wasm_bytes).ok()?;

    // Extract metadata based on decoded type
    let (package_name, world_name, import_count, export_count) = match &decoded {
        DecodedWasm::WitPackage(resolve, package_id) => {
            let package = resolve
                .packages
                .get(*package_id)
                .expect("Package ID should be valid");
            let pkg_name = format!("{}", package.name);
            // Use the first world name if available
            let world = package.worlds.iter().next().map(|(name, world_id)| {
                let w = resolve
                    .worlds
                    .get(*world_id)
                    .expect("World ID should be valid");
                (name.clone(), w.imports.len() as i32, w.exports.len() as i32)
            });
            let (world_name, imports, exports) = world.unwrap_or((package.name.name.clone(), 0, 0));
            (Some(pkg_name), world_name, imports, exports)
        }
        DecodedWasm::Component(resolve, world_id) => {
            let world = resolve
                .worlds
                .get(*world_id)
                .expect("World ID should be valid");
            // Try to get package name from world's package reference
            let pkg_name = world
                .package
                .and_then(|pid| resolve.packages.get(pid))
                .map(|p| format!("{}", p.name));
            (
                pkg_name,
                world.name.clone(),
                world.imports.len() as i32,
                world.exports.len() as i32,
            )
        }
    };

    // Generate a WIT text representation from the decoded structure
    let wit_text = generate_wit_text(&decoded);

    Some(WitMetadata {
        package_name,
        world_name,
        import_count,
        export_count,
        wit_text,
    })
}

/// Generate WIT text representation from decoded component.
fn generate_wit_text(decoded: &DecodedWasm) -> String {
    let resolve = decoded.resolve();

    match decoded {
        DecodedWasm::WitPackage(_, package_id) => {
            // Use wit-encoder to convert from wit-parser to WIT text
            let packages = wit_encoder::packages_from_parsed(resolve);

            // Find the package with the matching ID
            for package in &packages {
                let parser_package = resolve
                    .packages
                    .get(*package_id)
                    .expect("Package ID should be valid");
                // Match by comparing package names
                if package.name().namespace() == parser_package.name.namespace
                    && package.name().name().as_ref() == parser_package.name.name
                {
                    return package.to_string();
                }
            }

            // Fallback: if no match, use the first package
            packages.first().map(|p| p.to_string()).unwrap_or_default()
        }
        DecodedWasm::Component(_, world_id) => {
            // For components, encode all packages and find the one containing our world
            let packages = wit_encoder::packages_from_parsed(resolve);
            let world = resolve
                .worlds
                .get(*world_id)
                .expect("World ID should be valid");

            // If the world has a package, find it
            if let Some(package_id) = world.package {
                let parser_package = resolve
                    .packages
                    .get(package_id)
                    .expect("Package ID should be valid");
                for package in &packages {
                    if package.name().namespace() == parser_package.name.namespace
                        && package.name().name().as_ref() == parser_package.name.name
                    {
                        return package.to_string();
                    }
                }
            }

            // Fallback for components without a proper package: manual generation
            let mut output = String::new();
            output.push_str("// Inferred component interface\n");
            output.push_str(&format!("world {} {{\n", world.name));

            for (key, _item) in &world.imports {
                output.push_str(&format!("  import {};\n", world_key_to_string(key)));
            }
            for (key, _item) in &world.exports {
                output.push_str(&format!("  export {};\n", world_key_to_string(key)));
            }
            output.push_str("}\n");
            output
        }
    }
}

/// Convert a WorldKey to a string representation.
fn world_key_to_string(key: &wit_parser::WorldKey) -> String {
    match key {
        wit_parser::WorldKey::Name(name) => name.clone(),
        wit_parser::WorldKey::Interface(id) => format!("interface-{:?}", id),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn extract_returns_none_for_invalid_bytes() {
        let invalid_bytes = b"not a wasm component";
        assert!(extract_wit_metadata(invalid_bytes).is_none());
    }

    #[test]
    fn extract_returns_none_for_empty_bytes() {
        let empty_bytes: &[u8] = &[];
        assert!(extract_wit_metadata(empty_bytes).is_none());
    }

    #[test]
    fn extract_handles_core_wasm_module() {
        // A minimal valid core WebAssembly module (not a component)
        // Magic number + version + empty sections
        let core_module = [
            0x00, 0x61, 0x73, 0x6d, // \0asm magic
            0x01, 0x00, 0x00, 0x00, // version 1
        ];
        // Core modules may or may not be decoded - just ensure we don't panic
        let _ = extract_wit_metadata(&core_module);
    }

    #[test]
    fn extract_returns_none_for_random_bytes() {
        let random_bytes = [0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x11, 0x22, 0x33];
        assert!(extract_wit_metadata(&random_bytes).is_none());
    }

    #[test]
    fn world_key_name_converts_correctly() {
        let key = wit_parser::WorldKey::Name("my-import".to_string());
        assert_eq!(world_key_to_string(&key), "my-import");
    }

    #[test]
    fn world_key_interface_converts_to_debug_format() {
        use wit_parser::{Interface, Resolve};

        let mut resolve = Resolve::default();
        let interface = Interface {
            name: Some("test".to_string()),
            docs: Default::default(),
            types: Default::default(),
            functions: Default::default(),
            package: None,
            stability: Default::default(),
        };
        let id = resolve.interfaces.alloc(interface);

        let key = wit_parser::WorldKey::Interface(id);
        let result = world_key_to_string(&key);
        assert!(result.starts_with("interface-"), "got: {}", result);
    }

    #[test]
    fn generate_wit_text_for_wit_package() {
        use wit_parser::{Interface, Package, PackageName, Resolve, World};

        let mut resolve = Resolve::default();

        // Create interface
        let interface = Interface {
            name: Some("greeter".to_string()),
            docs: Default::default(),
            types: Default::default(),
            functions: Default::default(),
            package: None,
            stability: Default::default(),
        };
        let interface_id = resolve.interfaces.alloc(interface);

        // Create world
        let world = World {
            name: "hello".to_string(),
            docs: Default::default(),
            imports: Default::default(),
            exports: Default::default(),
            includes: Default::default(),
            include_names: Default::default(),
            package: None,
            stability: Default::default(),
        };
        let world_id = resolve.worlds.alloc(world);

        // Create package
        let package = Package {
            name: PackageName {
                namespace: "test".to_string(),
                name: "example".to_string(),
                version: None,
            },
            docs: Default::default(),
            interfaces: [("greeter".to_string(), interface_id)]
                .into_iter()
                .collect(),
            worlds: [("hello".to_string(), world_id)].into_iter().collect(),
        };
        let package_id = resolve.packages.alloc(package);

        // Update back-references
        resolve.interfaces[interface_id].package = Some(package_id);
        resolve.worlds[world_id].package = Some(package_id);

        // Create decoded structure directly (without encoding to binary)
        let decoded = DecodedWasm::WitPackage(resolve, package_id);
        let wit_text = generate_wit_text(&decoded);

        assert!(
            wit_text.contains("package test:example"),
            "should contain package name, got: {}",
            wit_text
        );
        assert!(
            wit_text.contains("interface greeter"),
            "should contain interface name, got: {}",
            wit_text
        );
        assert!(
            wit_text.contains("world hello"),
            "should contain world name, got: {}",
            wit_text
        );
    }

    #[test]
    fn generate_wit_text_for_component() {
        use wit_parser::{Resolve, World};

        let mut resolve = Resolve::default();

        // Create a world for a component
        let world = World {
            name: "my-component".to_string(),
            docs: Default::default(),
            imports: Default::default(),
            exports: Default::default(),
            includes: Default::default(),
            include_names: Default::default(),
            package: None,
            stability: Default::default(),
        };
        let world_id = resolve.worlds.alloc(world);

        let decoded = DecodedWasm::Component(resolve, world_id);
        let wit_text = generate_wit_text(&decoded);

        assert!(
            wit_text.contains("// Inferred component interface"),
            "should have component comment, got: {}",
            wit_text
        );
        assert!(
            wit_text.contains("world my-component"),
            "should contain world name, got: {}",
            wit_text
        );
    }

    #[test]
    fn generate_wit_text_with_imports_and_exports() {
        use wit_parser::{Function, FunctionKind, Resolve, World, WorldItem, WorldKey};

        let mut resolve = Resolve::default();

        let mut world = World {
            name: "test-world".to_string(),
            docs: Default::default(),
            imports: Default::default(),
            exports: Default::default(),
            includes: Default::default(),
            include_names: Default::default(),
            package: None,
            stability: Default::default(),
        };

        // Add named imports and exports using functions (which don't need TypeIds)
        world.imports.insert(
            WorldKey::Name("read-stdin".to_string()),
            WorldItem::Function(Function {
                name: "read-stdin".to_string(),
                kind: FunctionKind::Freestanding,
                params: vec![],
                result: None,
                docs: Default::default(),
                stability: Default::default(),
            }),
        );
        world.exports.insert(
            WorldKey::Name("run".to_string()),
            WorldItem::Function(Function {
                name: "run".to_string(),
                kind: FunctionKind::Freestanding,
                params: vec![],
                result: None,
                docs: Default::default(),
                stability: Default::default(),
            }),
        );

        let world_id = resolve.worlds.alloc(world);

        let decoded = DecodedWasm::Component(resolve, world_id);
        let wit_text = generate_wit_text(&decoded);

        assert!(
            wit_text.contains("import read-stdin"),
            "should contain import, got: {}",
            wit_text
        );
        assert!(
            wit_text.contains("export run"),
            "should contain export, got: {}",
            wit_text
        );
    }
}
